<html>
<head>
  <link rel="stylesheet" media="screen" href="style.css?v=8may2013">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />

<title>Keylight Android - NF28 Project</title>

  <link rel="stylesheet" media="screen" href="style.css?v=8may2013">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Keylight">
  <meta name="description" content="A NF28 project">
  <meta name="robots" content="all">
</head>
<body id="css-zen-garden">
  <div class="page-wrapper">
    <section class="intro" id="zen-intro">
    <header role="banner">
      <h1>Keylight</h1>
      <h2>A NF28 Project</h2>
    </header>

    <div class="summary" id="zen-summary" role="article">
      <p>L'objectif de ce projet est de développer une application Android offrant une nouvelle façon de gérer ses clefs. Keylight est une start-up qui développe la 1ere serrure connectée à ouverture lumineuse : elle utilise le flash du smartphone comme moyen d'ouverture.
Ainsi, l'application Android sera couplée à une API permettant d'interfacer notre base de données et nos applications. Bien que le projet dans le cadre de l'UV NF28 soit l'application Android, le Back-End et le Firmware de la serrure devaient etre développés en parallèle.</p>
    </div>

    <div class="preamble" id="zen-preamble" role="article">
      <h3>The Road to Enlightenment</h3>
      <p>Littering a dark and dreary road lay the past relics of browser-specific tags, incompatible <abbr title="Document Object Model">DOM</abbr>s, broken <abbr title="Cascading Style Sheets">CSS</abbr> support, and abandoned browsers.</p>
      <p>We must clear the mind of the past. Web enlightenment has been achieved thanks to the tireless efforts of folk like the <abbr title="World Wide Web Consortium">W3C</abbr>, <abbr title="Web Standards Project">WaSP</abbr>, and the major browser creators.</p>
      <p>The CSS Zen Garden invites you to relax and meditate on the important lessons of the masters. Begin to see with clarity. Learn to use the time-honored techniques in new and invigorating fashion. Become one with the web.</p>
    </div>
  </section>
  <h1>KEYLIGHT Android</h1>
<h2 id="objectif">Objectif</h2>
L'objectif de ce projet est de développer une application Android offrant une nouvelle façon de gérer ses clefs. Keylight est une start-up qui développe la 1ere serrure connectée à ouverture lumineuse : elle utilise le flash du smartphone comme moyen d'ouverture.
Ainsi, l'application Android sera couplée à une API permettant d'interfacer notre base de données et nos applications. Bien que le projet dans le cadre de l'UV NF28 soit l'application Android, le Back-End et le Firmware de la serrure devaient etre développés en parallèle.
<h2 id="cahier-des-charges">Cahier des charges</h2>
<h2 id="pr-sentation">Présentation</h2>
<p>Lors de l&#39;ouverture de l&#39;application, nous arrivons sur le premier onglet, qui est l&#39;onglet <em>Keys</em>. Cette onglet contient toutes les clefs de l&#39;utilisateur, que ce soit ces propres <em>DoorLocks</em> ou des <em>SharedKeys</em> (des clefs d&#39;autres <em>DoorLocks</em> qui lui ont été partagées).</p> Les couleurs sont fixes et permettent de distinguer les différentes <em>DoorLocks</em> et <em>SharedKeys</em>. Ainsi, l'utilisateur peut facilement et rapidement associer mentalement une clef à une couleur. Même si celui-ci ne peut clairement distinguer l'initiale au centre de la bulle selon les conditions extérieures et la luminosité, il peut se fier à se couleur.
<p><img src="locks_tab.png" alt="Onglet Keys" title="Onglet Keys" width="300"></p>
Sur cet onglet l'utilisateur peut faire plusieurs choses :
<ol>
  <li>
    Ajouter une <em>DoorLock</em> en cliquant sur le bouton <strong>+</strong>. Cela ouvre alors une modale permettant de renseigner les informations de cette <em>DoorLock</em>.
    <p><img src="add_lock.png" alt="Ajout de DoorLock" title="Ajout de DoorLock" width="300"></p>
  </li>
  <li>
    Déclencher le flash du téléphone par un simple <strong>tap</strong> sur une bulle. Le flash transmet alors un code en binaire à la serrure qui s'ouvre si ce code est correct. 
  </li>
  <li>
    Accéder aux différentes actions que l'on peut effectuer sur une <em>DoorLock</em> par un appui long sur une bulle.
    <p><img src="actions_lock.png" alt="Actions" title="Actions" width="300"></p>
    Si nous n'avons pas un accès administrateur à la serrure en question, un appui long ouvre simplement les informations relatives à la serrure :
    <p><img src="shared_key_info.png" alt="SharedKey info" title="SharedKey info" width="300"></p>
  </li>
</ol>
Les différentes actions que l'on peut effectuer sur une serrure dont nous sommes l'administrateur sont les suivantes :
<ol>
  <li>
    Accéder aux informations générales de la <em>DoorLock</em>
    <p><img src="lock_info.png" alt="DoorLock info" title="DoorLock info" width="300"></p>
    A partir de cette modale, nous pouvons accéder à la liste des personnes qui ont accès à la serrure :
    <p><img src="shared_with.png" alt="Liste des accès" title="Liste des accès" width="300"></p>
    Et nous pouvons partager la serrure en cliquant sur le bouton de partage en bas de l'écran, modifier des accès existants, ou les supprimer :
    <p><img src="action_shared_with.png" alt="Actions accès" title="Actions accès" width="300"></p>
  </li>
  <li>
    Partager la serrure à l'un de ses contacts :
    <p><img src="share.png" alt="Partager" title="Partager" width="300"></p>
    Une fois la personne choisie, il faut préciser le type d'accès (limité, illimité ou administrateur) :
    <p><img src="select_access_type.png" alt="Type d'accès" title="Type d'accès" width="300"></p>
    Enfin, une derniere fenetre permet de vérifier la transaction et de confirmer le partage :
    <p><img src="confirm_share.png" alt="Confirmation partage" title="Confirmation partage" width="300"></p>
  </li>
  <li>
    Supprimer la serrure
  </li>
</ol>
Pour ce qui est de l'onglet <strong>Contact</strong>, il est possible de supprimer des contacts par un appui long sur le contact, ou d'en ajouter en cliquant sur le bouton <strong>+</strong> :
<p><img src="contacts_tab.png" alt="Onglet contacts" title="Onglet contacts" width="300"></p>
<p><img src="add_contact.png" alt="Ajouter contact" title="Ajouter contact" width="300"></p>
Enfin, pour ce qui est de l'onglet <strong>Info</strong>, l'utilisateur peut modifier les informations liées à son compte :
<p><img src="settings_tab.png" alt="Onglet info" title="Onglet info" width="300"></p>
<p><img src="edit_own_info.png" alt="Editer info" title="Editer info" width="300"></p>
<h2 id="architecture">Architecture</h2>
<h3 id="architecture-du-syst-me">Architecture du système</h3>
<p><img src="system_architecture.png" alt="Architecture du système" title="Architecture du système"></p>
<p>A. <strong>Application Android</strong> (<em>Java</em>).</p>
<p>B. <strong>API</strong> (<em>Ruby On Rails</em>) hébergée dans le service <em>Elastic Beanstalk</em> de <em>AWS</em> (<em>Amazon Web Services</em>).</p>
<p>C. <strong>Base de données PostgreSQL</strong> hébergée dans le service <em>RDS</em> (<em>Relational Database Service</em>) de <em>AWS</em>.</p>
<p>D. <strong>Base de données locale Realm</strong> permettant de sauvegarder les données utilisateur même si l&#39;application est quittée. Ce choix a été fait afin de gérer plus facilement les objets, et de former dynamiquement les objets Java depuis des objets <em>JSON</em>.</p>
<ol>
<li>L&#39;application fait une requête à l&#39;API afin de récupérer les nouvelles données.</li>
<li>L&#39;API fait une requête sur les tables correspondantes de la BDD.</li>
<li>La BDD retourne les lignes des tables correspondant à la requête.</li>
<li>L&#39;API renvoie un <em>JSON</em> contenant les objets.</li>
<li>L&#39;application demande à la BDD locale de formatter les données brutes en objets.</li>
<li>La BDD locale sauvegarde et renvoie les objets Java.</li>
</ol>
<h3 id="architecture-de-l-application">Architecture de l&#39;application</h3>
<p>L&#39;architecture choisie pour cette application est l&#39;architecture <strong>MVC</strong>.</p>
<p><img src="MVC_structure.png" alt="Architecture MVC" title="Architecture MVC"></p>

<ol>
<li>L&#39;utilisateur change d&#39;onglet ou refraîchit une liste. La <em>View</em> demande au <em>Controller</em> les dernières données associées à la requête. Cette requête se fait via un <strong>RecyclerView</strong>, qui sait les requêtes nécessaires pour chaque <em>View</em>. Par exemple, le <em>LocksListFragment</em> possède un <em>LocksRecyclerView</em> qui sait que la requête de rafraichissement consiste à aller chercher les dernières <em>DoorLocks</em> et <em>SharedKeys</em> du <em>User</em>.

<pre>
protected void myOnRefresh() {
 try {
   getDataRequest();
 } catch (Exception e) {
   e.printStackTrace();
   stopRefreshing();
 }
}
public void getDataRequest() {
    final RequestsService requestsService = RequestsService.getInstance(getActivity().getApplicationContext());
    requestsService.getContacts();
}</pre>
</li>
<li>Si l&#39;application est connectée à Internet, le <em>Controller</em> lance une requête à l&#39;API afin de récupérer les dernières <em>DoorLocks</em> et <em>SharedKeys</em>. Sinon, il récupère les données sauvegardées dans la BDD Realm locale.
<pre>
public void getContacts() {

    if (!isNetworkAvailable()) {
         throwNetworkNotAvailable();
          return;
    }

    final String url = this.context.getString(R.string.url_api) + &quot;/contacts&quot;;

    final Response.Listener&lt;JSONArray&gt; onResponse = new Response.Listener&lt;JSONArray&gt;() {
          @Override
          public void onResponse(JSONArray response) {
            final DatabaseService databaseService = DatabaseService.getInstance(context);
            databaseService.saveContacts(SecureSharedPreferencesService.getInstance(context).getUserId(),
            response);
          }
    };

    final JsonRequestHelper jsonRequestHelper = new JsonRequestHelper(
        context,
        queue,
        url,
        RequestType.GET_JSON_ARRAY,
        null,
        onResponse,
        null);
    jsonRequestHelper.execute();
}</pre>
</li>
<li>Une fois la requête terminée, la BDD locale Realm stocke les nouvelles données et envoie un signal au <em>Controller</em> lui disant que les données sont prêtes. Ce signal est pris en charge par <strong>ReactiveX</strong>. Chaque <em>Controller</em> possède des <em>listener</em> à certains évènements <em>ReactiveX</em> (comme &quot;Realm a fini de sauvegarder les DoorLocks&quot; ou &quot;Realm a fini de supprimer les SharedKeys demandées&quot;), dépendant des données qu&#39;il gère.
<pre>
//------Model-------
public void saveContacts(final Long currentUserId, final JSONArray contacts) {
    int nbContactsSuccessfullySaved = 0;
    for (int i = 0; i &lt; contacts.length(); i++) {
        try {
            final JSONObject contactJSONObject = contacts.getJSONObject(i);
            saveContact(currentUserId, contactJSONObject);
            nbContactsSuccessfullySaved++;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    final ReactiveXService reactiveXService = ReactiveXService.getInstance(context);
    reactiveXService.fireSaveContactsPublishSubject(nbContactsSuccessfullySaved);
}
//------Controller-------
public void doOwnSubscriptions() {
    final ReactiveXService reactiveXService = ReactiveXService.getInstance(getActivity().getApplicationContext());
    reactiveXService.subscribeToSaveContactsPublishSubject(saveContactsObserver);
    reactiveXService.subscribeToDeleteContactPublishSubject(deleteContactObserver);
}
Disposable saveContactsDisposable = null;
final Observer<Integer> saveContactsObserver = new Observer<Integer>() {
@Override
public void onSubscribe(Disposable d) {
    if (saveContactsDisposable != null) {
        saveContactsDisposable.dispose();
      }
      saveContactsDisposable = d;
}

@Override
public void onComplete(final Integer nbContactsSaved) {
    updateUIList();
}
};</pre>
</li>
<li>Lorsque le <em>Controller</em> reçoit le signal de <em>ReactiveX</em>, il fait une requête sur la BDD Realm locale afin de récupérer les objets demandés. Il envoie alors ces objets à la vue qui les affiche en passant par un <strong>Adapter</strong>. Chaque vue possède un <em>Adapter</em> permettant de représenter les objets reçus au sein de la <em>View</em>.</li>
</ol>
<h3 id="structure-des-donn-es">Structure des données</h3>
<p><img src="data_structure.png" alt="Architecture des données" title="Architecture des données"></p>
<ul>
<li><em>User</em> : Cette classe représente un utilisateur. Il possède des objets <em>Contact</em>, des <em>DoorLock</em> et des <em>SharedKey</em>.</li>
<li><em>Contact</em> : Cette classe représente la relation entre deux <em>Users</em>. Lorsque d&#39;un <em>User</em> ajoute un autre <em>User</em> via son username ou son email, une demande lui ai envoyée.</li>
<li><em>DoorLock</em> : Cette classe représente une serrure. Elle est caractérisée par son numéro de série, qui sert à l&#39;activer lors de son installation. Elle possède également une adresse pour permettre de proposer des services et features de localisations à l&#39;utilisateur.</li>
<li><em>SharedKey</em> : Cette classe représente un accès spécifique à une <em>DoorLock</em> pour un <em>User</em> donné. Chaque <em>SharedKey</em> possède une date de début, de fin et un booléen qui indique si le <em>User</em> est admin est peut alors partager et gérer la <em>DoorLock</em> à son tour.</li>
</ul>
<h2 id="evaluations-utilisateurs">Evaluations utilisateurs</h2>
<h2 id="limites-et-am-liorations-possibles">Limites et améliorations possibles</h2>
Par manque de temps et d'effectif, certaines fonctionnalités n'ont pas pu être implémentées :
<ul>
  <li>
    <strong>L'affichage du temps restant au niveau des SharedKeys</strong>: autant au niveau de la modale d'informations lors d'un appui long, qu'au niveau de la liste des accès d'une <em>DoorLock</em>, le serveur devrait pouvoir nous renvoyer le temps restant d'une <em>SharedKey</em>. Ce travail sera effectué au niveau de l'API : lors du renvoi des <em>SharedKeys</em> associées à une <em>DoorLock</em> (suite à une requête), l'API devra calculer le temps restant et l'insérer dans l'objet <em>JSON</em> retourné. En effet, un tel calcul ne doit pas être effectué au niveau de l'application, celle-ci devant avoir le moins de logique possible pour rendre la rendre plus légère.
  </li>
  <li>
    <strong>La géolocalisation de l'utilisateur</strong> : pourvoir géolocaliser l'utilisateur permet de lui envoyer une notification lorsqu'il approche de chez lui, et de lui proposer de lancer le flash depuis son écran de verrouillage. Cela limite alors drastiquement le nombre de <strong>taps</strong> nécessaires avant l'ouverture de la porte. Lorsque l'utilisateur se trouve dans l'application, nous pourrions alors mettre en avant les clefs les plus suceptibles d'etre utilisées en fonction de sa position géographique. Cette fonctionnalité pourrait être implémentée au niveau interne de l'application : l'application stocke les addresses des serrures. Ainsi, il suffit de récupérer la position de l'utilisateur et d'envoyer une notification dès qu'il s'approche de l'une d'elles.
  </li>
  <li>
    <strong>La gestion intelligente des couleurs des clefs</strong> : dans la dernière version de l'application, les couleurs sont codées en dur et ne sont alors ni modifiables, ni similaires pour une même clef entre deux smartphones différents. Nous voulions mettre en place le système suivant : pouvoir préciser le type de la serrure au moment de son ajout (porte d'entrée, porte de garage, portail, porte secondaire, etc...). Ainsi, il serait plus aisé de reconnaitre la serrure avec son code couleur, sans avoir besoin de vérifier son nom. Ce code couleur serait alors commun à tous les smartphones.
  </li>
  <li>
    <strong>La gestion des groupes de clefs</strong> : pouvoir regrouper les clefs automatiquement en fonction du logement. Ainsi, lors de l'ouverture de l'application, seuls les logements seraient affichés. Chaque logement serait représenté par une bulle. Si l'on clique sur cette bulle, nous avons accès à l'ensemble des clefs de ce logement. Cette fonctionnalité est importante et nous n'avons pas eu le temps de l'implémenter car elle nécessite une étape important : le couplage de la serrure avec le <strong>Bridge</strong>. Le <strong>Bridge</strong> est un dispositif servant de passerelle entre la serrure et notre serveur. Un Bridge est commun à toutes les serrures d'un logement, et c'est cela qui permet de regrouper les serrures au niveau du serveur. En effet, lors du couplage, la serrure est associée au Bridge du logement. Ce n'est pas l'adresse qui permet de les relier, car cette adresse ne sera rentrée que lors de l'installation de la 1ere serrure au sein du logement.
  </li>
</ul>
</div>
</body>
</html>
