<html>
<head>
  <link rel="stylesheet" media="screen" href="style.css?v=8may2013">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />

<title>Keylight Android - NF28 Project</title>

  <link rel="stylesheet" media="screen" href="style.css?v=8may2013">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Keylight">
  <meta name="description" content="A NF28 project">
  <meta name="robots" content="all">
</head>
<body id="css-zen-garden">
  <div class="page-wrapper">
    <section class="intro" id="zen-intro">
    <header role="banner">
      <h1>Keylight</h1>
      <h2>A NF28 Project</h2>
    </header>
  </section>
  <div class="main supporting" id="zen-supporting" role="main">
  <h1>KEYLIGHT Android</h1>
    <div class="explanation" id="zen-explanation" role="article">
      <h2>Objectif</h2>
L'objectif de ce projet est de développer une application Android offrant une nouvelle façon de gérer ses clefs. Keylight est une start-up qui développe la 1ere serrure connectée à ouverture lumineuse : elle utilise le flash du smartphone comme moyen d'ouverture.
Ainsi, l'application Android sera couplée à une API permettant d'interfacer notre base de données et nos applications. Bien que le projet dans le cadre de l'UV NF28 soit l'application Android, le Back-End et le Firmware de la serrure devaient etre développés en parallèle. Les solutions existantes de nos jours ne s'orientent pas vers une utilisation intuituve et rapide de l'application. Nous souhaitons nous concentrer sur un trvail d'ergonomi et d'User Experience afin que l'utilisateur perde le moins de temps possible à chercher, gérer et utiliser ses clefs.</p>
<h2 id="cahier-des-charges">Cahier des charges</h2>
Ci-dessous le cahier des charges que nous souhaitions réaliser :
<h3>Principales fonctionnalités</h3>
<ul>
<li><strong>Ajout de serrures</strong> : L’utilisateur doit pouvoir installer une nouvelles serrure en entrant le numéro de série de l’appareil. Il devient alors le propriétaire de cette serrure.</li>

<li><strong>Organisation des serrures</strong> : L’utilisateur doit pouvoir regrouper les serrures comme il le souhaite ainsi que les agencer afin que cela soit plus pratique pour lui des les retrouver.</li>

<li><strong>Edition des serrures</strong> : L’utilisateur doit avoir la possibilité d’éditer les informations d’une serrure (nom, adresse).</li>

<li><strong>Partage d’une serrure</strong> : L’utilisateur doit avoir la possibilité de donner un accès limité ou non à une serrure à un de ses contacts.</li>

<li><strong>Liste des accès</strong> : L’utilisateur doit pouvoir accéder à la liste des accès autorisés à une serrure. Il doit alors pouvoir les modifier et/ou les supprimer.</li>

<li><strong>Accès partagés</strong> : L’utilisateur doit pouvoir accéder aux serrures qui lui sont partagées. De même que ses propres serrures, il doit pouvoir els organiser comme il le souhaite. Il peut partager une de ces serrures si l’accès qui lui a été attribué est un accès « Admin ». Un « Admin » peut gérer tous les accès à une serrure.</li>

<li><strong>Contacts</strong> : L’utilisateur doit pouvoir ajouter/supprimer des utilisateurs et ainsi gérer sa liste de contacts.</li>
</ul>
<h3>Features</h3>
<ul>
<li><strong>Notifications</strong>  : Afin de pouvoir ouvrir rapidement un serrure, l’utilisateur doit recevoir une notification à l’approche d’une de ses serrures. Cette notification lui permet d’accéder directement à l’application. Il peut alors lancer le mécanisme d’ouverture (transmission du flash) par le simple déverrouillage de son smartphone.</li>

<li><strong>Informations personnelles</strong> : L’utilisateur doit avoir la possibilité de modifier les informations liées à son compte (identifiant, email, nom, prénom, …).</li>

<li><strong>Historique des accès</strong> : L’utilisateur doit pouvoir accéder à l’historique des verrouillages/déverrouillages des serrures. Chaque entrée doit être accompagnée des informations de la personnes ayant ouvert/fermé la porte.</li>
</ul>
<h2 id="pr-sentation">Présentation</h2>
<p>Lors de l&#39;ouverture de l&#39;application, nous arrivons sur le premier onglet, qui est l&#39;onglet <em>Keys</em>. Cette onglet contient toutes les clefs de l&#39;utilisateur, que ce soit ces propres <em>DoorLocks</em> ou des <em>SharedKeys</em> (des clefs d&#39;autres <em>DoorLocks</em> qui lui ont été partagées).</p> Les couleurs sont fixes et permettent de distinguer les différentes <em>DoorLocks</em> et <em>SharedKeys</em>. Ainsi, l'utilisateur peut facilement et rapidement associer mentalement une clef à une couleur. Même si celui-ci ne peut clairement distinguer l'initiale au centre de la bulle selon les conditions extérieures et la luminosité, il peut se fier à se couleur.
<p><img src="locks_tab.png" alt="Onglet Keys" title="Onglet Keys" width="300"></p>
Sur cet onglet l'utilisateur peut faire plusieurs choses :
<ol>
  <li>
    Ajouter une <em>DoorLock</em> en cliquant sur le bouton <strong>+</strong>. Cela ouvre alors une modale permettant de renseigner les informations de cette <em>DoorLock</em>.
    <p><img src="add_lock.png" alt="Ajout de DoorLock" title="Ajout de DoorLock" width="300"></p>
  </li>
  <li>
    Déclencher le flash du téléphone par un simple <strong>tap</strong> sur une bulle. Le flash transmet alors un code en binaire à la serrure qui s'ouvre si ce code est correct. 
  </li>
  <li>
    Accéder aux différentes actions que l'on peut effectuer sur une <em>DoorLock</em> par un appui long sur une bulle.
    <p><img src="actions_lock.png" alt="Actions" title="Actions" width="300"></p>
    Si nous n'avons pas un accès administrateur à la serrure en question, un appui long ouvre simplement les informations relatives à la serrure :
    <p><img src="shared_key_info.png" alt="SharedKey info" title="SharedKey info" width="300"></p>
  </li>
</ol>
Les différentes actions que l'on peut effectuer sur une serrure dont nous sommes l'administrateur sont les suivantes :
<ol>
  <li>
    Accéder aux informations générales de la <em>DoorLock</em>
    <p><img src="lock_info.png" alt="DoorLock info" title="DoorLock info" width="300"></p>
    A partir de cette modale, nous pouvons accéder à la liste des personnes qui ont accès à la serrure :
    <p><img src="shared_with.png" alt="Liste des accès" title="Liste des accès" width="300"></p>
    Et nous pouvons partager la serrure en cliquant sur le bouton de partage en bas de l'écran, modifier des accès existants, ou les supprimer :
    <p><img src="action_shared_with.png" alt="Actions accès" title="Actions accès" width="300"></p>
  </li>
  <li>
    Partager la serrure à l'un de ses contacts :
    <p><img src="share.png" alt="Partager" title="Partager" width="300"></p>
    Une fois la personne choisie, il faut préciser le type d'accès (limité, illimité ou administrateur) :
    <p><img src="select_access_type.png" alt="Type d'accès" title="Type d'accès" width="300"></p>
    Enfin, une derniere fenetre permet de vérifier la transaction et de confirmer le partage :
    <p><img src="confirm_share.png" alt="Confirmation partage" title="Confirmation partage" width="300"></p>
  </li>
  <li>
    Supprimer la serrure
  </li>
</ol>
Pour ce qui est de l'onglet <strong>Contact</strong>, il est possible de supprimer des contacts par un appui long sur le contact, ou d'en ajouter en cliquant sur le bouton <strong>+</strong> :
<p><img src="contacts_tab.png" alt="Onglet contacts" title="Onglet contacts" width="300"></p>
<p><img src="add_contact.png" alt="Ajouter contact" title="Ajouter contact" width="300"></p>
Enfin, pour ce qui est de l'onglet <strong>Info</strong>, l'utilisateur peut modifier les informations liées à son compte :
<p><img src="settings_tab.png" alt="Onglet info" title="Onglet info" width="300"></p>
<p><img src="edit_own_info.png" alt="Editer info" title="Editer info" width="300"></p>
<h2 id="architecture">Architecture</h2>
<h3 id="architecture-du-syst-me">Architecture du système</h3>
<p><img src="system_architecture.png" alt="Architecture du système" title="Architecture du système"></p>
<p>A. <strong>Application Android</strong> (<em>Java</em>).</p>
<p>B. <strong>API</strong> (<em>Ruby On Rails</em>) hébergée dans le service <em>Elastic Beanstalk</em> de <em>AWS</em> (<em>Amazon Web Services</em>).</p>
<p>C. <strong>Base de données PostgreSQL</strong> hébergée dans le service <em>RDS</em> (<em>Relational Database Service</em>) de <em>AWS</em>.</p>
<p>D. <strong>Base de données locale Realm</strong> permettant de sauvegarder les données utilisateur même si l&#39;application est quittée. Ce choix a été fait afin de gérer plus facilement les objets, et de former dynamiquement les objets Java depuis des objets <em>JSON</em>.</p>
<ol>
<li>L&#39;application fait une requête à l&#39;API afin de récupérer les nouvelles données.</li>
<li>L&#39;API fait une requête sur les tables correspondantes de la BDD.</li>
<li>La BDD retourne les lignes des tables correspondant à la requête.</li>
<li>L&#39;API renvoie un <em>JSON</em> contenant les objets.</li>
<li>L&#39;application demande à la BDD locale de formatter les données brutes en objets.</li>
<li>La BDD locale sauvegarde et renvoie les objets Java.</li>
</ol>
<h3 id="architecture-de-l-application">Architecture de l&#39;application</h3>
<p>L&#39;architecture choisie pour cette application est l&#39;architecture <strong>MVC</strong>.</p>
<p><img src="MVC_structure.png" alt="Architecture MVC" title="Architecture MVC"></p>

<ol>
<li>L&#39;utilisateur change d&#39;onglet ou refraîchit une liste. La <em>View</em> demande au <em>Controller</em> les dernières données associées à la requête. Cette requête se fait via un <strong>RecyclerView</strong>, qui sait les requêtes nécessaires pour chaque <em>View</em>. Par exemple, le <em>LocksListFragment</em> possède un <em>LocksRecyclerView</em> qui sait que la requête de rafraichissement consiste à aller chercher les dernières <em>DoorLocks</em> et <em>SharedKeys</em> du <em>User</em>.

<pre><code> 
protected void myOnRefresh() {
 try {
   getDataRequest();
 } catch (Exception e) {
   e.printStackTrace();
   stopRefreshing();
 }
}
public void getDataRequest() {
    final RequestsService requestsService = RequestsService.getInstance(getActivity().getApplicationContext());
    requestsService.getContacts();
}</code></pre>
</li>
<li>Si l&#39;application est connectée à Internet, le <em>Controller</em> lance une requête à l&#39;API afin de récupérer les dernières <em>DoorLocks</em> et <em>SharedKeys</em>. Sinon, il récupère les données sauvegardées dans la BDD Realm locale.
<pre><code>
public void getContacts() {

    if (!isNetworkAvailable()) {
         throwNetworkNotAvailable();
          return;
    }

    final String url = this.context.getString(R.string.url_api) + &quot;/contacts&quot;;

    final Response.Listener&lt;JSONArray&gt; onResponse = new Response.Listener&lt;JSONArray&gt;() {
          @Override
          public void onResponse(JSONArray response) {
            final DatabaseService databaseService = DatabaseService.getInstance(context);
            databaseService.saveContacts(SecureSharedPreferencesService.getInstance(context).getUserId(),
            response);
          }
    };

    final JsonRequestHelper jsonRequestHelper = new JsonRequestHelper(
        context,
        queue,
        url,
        RequestType.GET_JSON_ARRAY,
        null,
        onResponse,
        null);
    jsonRequestHelper.execute();
}</code></pre>
</li>
<li>Une fois la requête terminée, la BDD locale Realm stocke les nouvelles données et envoie un signal au <em>Controller</em> lui disant que les données sont prêtes. Ce signal est pris en charge par <strong>ReactiveX</strong>. Chaque <em>Controller</em> possède des <em>listener</em> à certains évènements <em>ReactiveX</em> (comme &quot;Realm a fini de sauvegarder les DoorLocks&quot; ou &quot;Realm a fini de supprimer les SharedKeys demandées&quot;), dépendant des données qu&#39;il gère.
<pre><code>
//------Model-------
public void saveContacts(final Long currentUserId, final JSONArray contacts) {
    int nbContactsSuccessfullySaved = 0;
    for (int i = 0; i &lt; contacts.length(); i++) {
        try {
            final JSONObject contactJSONObject = contacts.getJSONObject(i);
            saveContact(currentUserId, contactJSONObject);
            nbContactsSuccessfullySaved++;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    final ReactiveXService reactiveXService = ReactiveXService.getInstance(context);
    reactiveXService.fireSaveContactsPublishSubject(nbContactsSuccessfullySaved);
}
//------Controller-------
public void doOwnSubscriptions() {
    final ReactiveXService reactiveXService = ReactiveXService.getInstance(getActivity().getApplicationContext());
    reactiveXService.subscribeToSaveContactsPublishSubject(saveContactsObserver);
    reactiveXService.subscribeToDeleteContactPublishSubject(deleteContactObserver);
}
Disposable saveContactsDisposable = null;
final Observer<Integer> saveContactsObserver = new Observer<Integer>() {
@Override
public void onSubscribe(Disposable d) {
    if (saveContactsDisposable != null) {
        saveContactsDisposable.dispose();
      }
      saveContactsDisposable = d;
}

@Override
public void onComplete(final Integer nbContactsSaved) {
    updateUIList();
}
};</code></pre>
</li>
<li>Lorsque le <em>Controller</em> reçoit le signal de <em>ReactiveX</em>, il fait une requête sur la BDD Realm locale afin de récupérer les objets demandés. Il envoie alors ces objets à la vue qui les affiche en passant par un <strong>Adapter</strong>. Chaque vue possède un <em>Adapter</em> permettant de représenter les objets reçus au sein de la <em>View</em>.</li>
</ol>
<h3 id="structure-des-donn-es">Structure des données</h3>
<p><img src="data_structure.png" alt="Architecture des données" title="Architecture des données"></p>
<ul>
<li><em>User</em> : Cette classe représente un utilisateur. Il possède des objets <em>Contact</em>, des <em>DoorLock</em> et des <em>SharedKey</em>.</li>
<li><em>Contact</em> : Cette classe représente la relation entre deux <em>Users</em>. Lorsque d&#39;un <em>User</em> ajoute un autre <em>User</em> via son username ou son email, une demande lui ai envoyée.</li>
<li><em>DoorLock</em> : Cette classe représente une serrure. Elle est caractérisée par son numéro de série, qui sert à l&#39;activer lors de son installation. Elle possède également une adresse pour permettre de proposer des services et features de localisations à l&#39;utilisateur.</li>
<li><em>SharedKey</em> : Cette classe représente un accès spécifique à une <em>DoorLock</em> pour un <em>User</em> donné. Chaque <em>SharedKey</em> possède une date de début, de fin et un booléen qui indique si le <em>User</em> est admin est peut alors partager et gérer la <em>DoorLock</em> à son tour.</li>
</ul>
<h2 id="evaluations-utilisateurs">Evaluations</h2>

Pour ce qui est des évaluations, nous avons effectué plusieurs tests utilisateurs informels au fur et à mesure de l'évolution du design. Nous avons mis à disposition des maquettes interactives minimales afin de vérifier l'intuitivité de l'application. Nous voulions savoi si l'utilisateur arrivait à trouver de lui-même comment utiliser les simples fonctionnalités de l'application.
<p><img src="first_design.png" alt="Premiere maquette" title="Premiere maquette"></p>

Cette première maquette nous a permis de confirmer l'aspect non-intuitif des listes en ce qui concerne les clefs. Lorsque qu'un grand nombre de clefs est présent, il devient alors compliqué de trouver celle que nous cherchons. De plus, la séparation des clefs propres et des clefs partagées n'est pas cohérent : un perte de place est engendrée si la personne ne possède pas de clefs propres et utilise l'application uniquement dans le but d'ouvrir une serrure partagée. Cette première maquette avait été implémentée completement afin de finaliser l'aspect fonctionnel de l'application. IL ne restait plus qu'à trouver la meilleure représentation des clefs.

<p><img src="second_design.png" alt="Seconde maquette" title="Seconde maquette"></p>

Cette deuxième maquette réunie tous les types de clefs au même endroit, et les groupes de clefs permettent de distinguer les différents logements. Néanmoins, la barre d'onglets située dans la partie supérieure de l'écran empêche une bonne fluidité de la navigation. En effet, à une main et sur des smartphones relativement grands, il devient difficile d'atteindre ces onglets.

<p><img src="last_design.png" alt="Dernière maquette" title="Dernière maquette"></p>


<h2 id="limites-et-am-liorations-possibles">Limites et améliorations possibles</h2>
Par manque de temps et d'effectif, certaines fonctionnalités n'ont pas pu être implémentées :
<ul>
  <li>
    <strong>L'affichage du temps restant au niveau des SharedKeys</strong>: autant au niveau de la modale d'informations lors d'un appui long, qu'au niveau de la liste des accès d'une <em>DoorLock</em>, le serveur devrait pouvoir nous renvoyer le temps restant d'une <em>SharedKey</em>. Ce travail sera effectué au niveau de l'API : lors du renvoi des <em>SharedKeys</em> associées à une <em>DoorLock</em> (suite à une requête), l'API devra calculer le temps restant et l'insérer dans l'objet <em>JSON</em> retourné. En effet, un tel calcul ne doit pas être effectué au niveau de l'application, celle-ci devant avoir le moins de logique possible pour rendre la rendre plus légère.
  </li>
  <li>
    <strong>La géolocalisation de l'utilisateur</strong> : pourvoir géolocaliser l'utilisateur permet de lui envoyer une notification lorsqu'il approche de chez lui, et de lui proposer de lancer le flash depuis son écran de verrouillage. Cela limite alors drastiquement le nombre de <strong>taps</strong> nécessaires avant l'ouverture de la porte. Lorsque l'utilisateur se trouve dans l'application, nous pourrions alors mettre en avant les clefs les plus suceptibles d'etre utilisées en fonction de sa position géographique. Cette fonctionnalité pourrait être implémentée au niveau interne de l'application : l'application stocke les addresses des serrures. Ainsi, il suffit de récupérer la position de l'utilisateur et d'envoyer une notification dès qu'il s'approche de l'une d'elles.
  </li>
  <li>
    <strong>La gestion intelligente des couleurs des clefs</strong> : dans la dernière version de l'application, les couleurs sont codées en dur et ne sont alors ni modifiables, ni similaires pour une même clef entre deux smartphones différents. Nous voulions mettre en place le système suivant : pouvoir préciser le type de la serrure au moment de son ajout (porte d'entrée, porte de garage, portail, porte secondaire, etc...). Ainsi, il serait plus aisé de reconnaitre la serrure avec son code couleur, sans avoir besoin de vérifier son nom. Ce code couleur serait alors commun à tous les smartphones.
  </li>
  <li>
    <strong>La gestion des groupes de clefs</strong> : pouvoir regrouper les clefs automatiquement en fonction du logement. Ainsi, lors de l'ouverture de l'application, seuls les logements seraient affichés. Chaque logement serait représenté par une bulle. Si l'on clique sur cette bulle, nous avons accès à l'ensemble des clefs de ce logement. Cette fonctionnalité est importante et nous n'avons pas eu le temps de l'implémenter car elle nécessite une étape important : le couplage de la serrure avec le <strong>Bridge</strong>. Le <strong>Bridge</strong> est un dispositif servant de passerelle entre la serrure et notre serveur. Un Bridge est commun à toutes les serrures d'un logement, et c'est cela qui permet de regrouper les serrures au niveau du serveur. En effet, lors du couplage, la serrure est associée au Bridge du logement. Ce n'est pas l'adresse qui permet de les relier, car cette adresse ne sera rentrée que lors de l'installation de la 1ere serrure au sein du logement.
  </li>
</ul>
</div>
</div>
</body>
</html>
